### 能被遍历的就不 hard code

本准则也可叫做“**数据驱动程序**”或“**表驱动**”。即让计算机做其最擅长的事——重复。

> 问题越一般化，解决起来就可能越容易。——《How to Solve It》Polya

现在的问题就变成了——如何让一个问题一般化？即如何将问题抽象出其共性，共性部分对于每个个体来说就可以使用重复，特性部分就可以通过不同的数据来体现，也即“**数据驱动**”。

#### 反例：

```html
<el-bigdata-table
    :data="operationDefectData"
    border
    class="table-data"
    height="380"
    size="mini"
>
    <el-table-column label="STEP_ID" width="80px" prop="stepId"></el-table-column>
    <el-table-column label="INSPECTION_TIME" width="160px" prop="inspectionTime"></el-table-column>
    <el-table-column label="GLASS_ID" width="100px" prop="glassId"></el-table-column>
    <el-table-column label="CHIP_NO" width="80px" prop="chipId"></el-table-column>
    <el-table-column label="X" width="80px" prop="x"></el-table-column>
    <el-table-column label="Y" width="80px" prop="y"></el-table-column>
    <el-table-column label="X2" width="80px" prop="x2"></el-table-column>
    <el-table-column label="Y2" width="80px" prop="y2"></el-table-column>
    <el-table-column label="IMAGE_DATA" width="300px" prop="imageData"></el-table-column>
    <el-table-column label="DEFECT_CODE" width="120px" prop="defectCode"></el-table-column>
    <el-table-column label="MARK_TYPE" width="100px" prop="markType"></el-table-column>
    <el-table-column label="FIELD" width="80px" prop="filed"></el-table-column>
    <el-table-column label="DEFECT_SIZE" width="120px" prop="defectSize"></el-table-column>
    <el-table-column label="SHIP_ID" width="80px" prop="shipId"></el-table-column>
    <el-table-column label="S" width="80px" prop="s"></el-table-column>
    <el-table-column label="G" width="80px" prop="g"></el-table-column>
    <!--<el-table-column label="WIDTH" width="80px" prop="width"></el-table-column>
    <el-table-column label="HEIGHT" width="80px" prop="height"></el-table-column>-->
    <el-table-column label="IS_FRONT_SIDE" width="120px" prop="isFrontSide"></el-table-column>
    <el-table-column label="RETYPE" width="80px" prop="retype"></el-table-column>
</el-bigdata-table>
<!-- 阅读该段程序时，需要一个个去辨别每个的共性与不同，而且增删修改时所作改动较大 -->
```

调整：

```vue
<el-bigdata-table
    :data="operationDefectData"
    border
    class="table-data"
    height="380"
    size="mini"
>
    <el-table-column
        v-for="field in columns" :key="field.prop"
        :label="field.label" :width="field.width" :prop="field.prop"></el-table-column>
</el-bigdata-table>

<script>
// 数据驱动里的“数据”  
const columns = [
  {label: 'STEP_ID', prop: 'stepId', width: '80px'},
  {label: 'GLASS_ID', prop: 'glassId', width: '100px'},
  {label: 'CHIP_NO', prop: 'chipNo', width: '80px'}
  // ... 增删方便，改动小
]
</script>

<!-- 调整后的程序清晰可辨，简洁明了，易于修改，阅读时几乎没什么心智成本。 -->
```



#### 反例2：

```js
export function backFill(_this, conditions,row){
  if(conditions[0].tablename)
    _this.tablename = conditions[0].tablename
  if(conditions[0].groupName)
    _this.$store.state.s.groupName = conditions[0].groupName
  if(conditions[0].createDate)
    _this.$store.state.s.createDate = conditions[0].createDate
  if(conditions[0].querySql)
    _this.$store.state.s.querySql = conditions[0].querySql

  if(row.actionName == 'Manual'){   // Manual
    if(conditions[0].targetCol)
      _this.$store.state.s.targetCol = conditions[0].targetCol
    if(conditions[0].distinctData)
      _this.$store.state.s.distinctData = conditions[0].distinctData
    if(conditions[0].groupData1)
      _this.$store.state.s.groupData1 = conditions[0].groupData1
  }
  if(row.actionName == 'Numeric'){
    if(conditions[0].targetCol2)
      _this.$store.state.s.targetCol2 = conditions[0].targetCol2
    if(conditions[0].minNum)
      _this.$store.state.s.minNum = conditions[0].minNum
    if(conditions[0].maxNum)
      _this.$store.state.s.maxNum = conditions[0].maxNum
    if(conditions[0].minArea)
      _this.$store.state.s.minArea = conditions[0].minArea
    if(conditions[0].maxArea)
      _this.$store.state.s.maxArea = conditions[0].maxArea
    if(conditions[0].relation)
      _this.$store.state.s.relation = conditions[0].relation
    if(conditions[0].relation2)
      _this.$store.state.s.relation2 = conditions[0].relation2
    if(conditions[0].groupData2)
      _this.$store.state.s.groupData2 = conditions[0].groupData2
  }
  if(row.actionName == 'Text & Date Time'){
    if(conditions[0].targetCol3)
      _this.$store.state.s.targetCol3 = conditions[0].targetCol3
    if(conditions[0].relation3)
      _this.$store.state.s.relation3 = conditions[0].relation3
    if(conditions[0].columnValues)
      _this.$store.state.s.columnValues = conditions[0].columnValues
    if(conditions[0].fieldValue)
      _this.$store.state.s.fieldValue = conditions[0].fieldValue
    if(conditions[0].likeValue)
      _this.$store.state.s.likeValue = conditions[0].likeValue
    if(conditions[0].groupData3)
      _this.$store.state.s.groupData3 = conditions[0].groupData3
  }
  if(row.actionName == 'Automation'){
    if(conditions[0].targetCol4)
      _this.$store.state.s.targetCol4 = conditions[0].targetCol4
    if(conditions[0].groupNum)
      _this.$store.state.s.groupNum = conditions[0].groupNum
    if(conditions[0].groupInterval)
      _this.$store.state.s.groupInterval = conditions[0].groupInterval
    if(conditions[0].checkMethod)
      _this.$store.state.s.checkMethod = conditions[0].checkMethod
    if(conditions[0].ifChecked)
      _this.$store.state.s.ifChecked = conditions[0].ifChecked
    if(conditions[0].ifDisabled)
      _this.$store.state.s.ifDisabled = conditions[0].ifDisabled
    if(conditions[0].upperLimit)
      _this.$store.state.s.upperLimit = conditions[0].upperLimit
    if(conditions[0].lowerLimit)
      _this.$store.state.s.lowerLimit = conditions[0].lowerLimit
  }
  if(row.actionName == 'Parameter'){
    if(conditions[0].targetCol5)
      _this.$store.state.s.targetCol5 = conditions[0].targetCol5
    if(conditions[0].startTime)
      _this.$store.state.s.startTime = conditions[0].startTime
    if(conditions[0].offsetNum)
      _this.$store.state.s.offsetNum = conditions[0].offsetNum
    if(conditions[0].offsetType)
      _this.$store.state.s.offsetType = conditions[0].offsetType
    if(conditions[0].groupData5)
      _this.$store.state.s.groupData5 = conditions[0].groupData5
  }
}
```

正例：

```js
const fields = {
  fields1: ['targetCol', 'distinctData', 'groupData1'],
  fields2: ['targetCol2', 'minNum', 'maxNum', 'minArea', 'maxArea', 'relation', 'relation2', 'groupData2'],
  fields3: ['targetCol3', 'relation3', 'columnValues', 'equalValue', 'inValues', 'betweenUpValue', 'likeValue', 'groupData3', 'textAndDateArr'],
  fields4: ['targetCol4', 'groupNum', 'groupSuffixLen', 'checkMethod', 'customBound', 'enableEditBound', 'upBound', 'lowBound'],
  fields5: ['targetCol5', 'startTime', 'splitType', 'sortArea', 'groupData5', 'groupCnt_EVR', 'groupCnt_RC', 'groupCNT_PNR', 'splitByDate']
}
const actionNames = [0, 'Manual', 'Numeric', 'Text & Date Time', 'AutoMation', 'Parameter']
const activeNames = [0, 'first', 'second', 'third', 'fourth', 'fifth']

export function backFill(vm, conditions, row) {
  const condition = conditions[0]
  fillCommon(vm, condition)
  let idx = actionNames.indexOf(row.actionName)
  vm.$store.state.split.activeName = activeNames[idx]
  vm.$nextTick(() => {
    fields[`fields${idx}`].forEach(f => condition[f] && (vm.$store.state.split[f] = condition[f]))
  })
}

function fillCommon(_this, condition) {
  if (condition.tablename) _this.tablename = condition.tablename

  if (condition.groupName) _this.$store.state.split.groupName = condition.groupName
  if (condition.createDate) _this.$store.state.split.createDate = condition.createDate
  if (condition.querySql) _this.$store.state.split.querySql = condition.querySql
  if (condition.columnData) _this.$store.state.split.columnData = JSON.parse(condition.columnData)
  if (condition.aliasName) _this.$store.state.split.aliasName = condition.aliasName

  if (condition.dataSourceUI) _this.$store.state.quickFieldForm.dataSource = condition.dataSourceUI
  if (condition.dataSourceSql) _this.$store.state.quickFieldForm.sql = condition.dataSourceSql
}
```



思辨：

1. 此处**反例2**中的代码除了代码行数多，真的一无是处吗？
2. **正例**中的代码除了行数少，真的做到足够清晰明了吗？

### 封装复杂的结构

反例：

```js
// 省略很多用来对 mail 信息进行参数检查的 if 

let realToAddresses = this.initPage.toAddress;
let toGroup = this.initPage.mailGroup.find(group => group.label === this.initPage.toAddress);
if (toGroup) {
    realToAddresses = toGroup.children.toString();
}
let realCcAddresses = this.initPage.ccAddress;
let ccGroup = this.initPage.mailGroup.find(group => group.label === this.initPage.ccAddress);
if (ccGroup) {
    realCcAddresses = ccGroup.children.toString();
}
const mailDTO = {
    'bcc': this.initPage.bccAddress,
    'cc': realCcAddresses,
    'subject': this.initPage.subject,
    'text': this.initPage.content,
    'to': realToAddresses,
    'ccMailGroup': this.initPage.ccMailMode === '2' ? this.initPage.ccAddress.join(",") : '',
    'toMailGroup': this.initPage.toMailMode === '2' ? this.initPage.toAddress.join(",") : ''
};

// 这些代码都堆在程序执行逻辑中，拉长了代码，分散了阅读注意力
// 实际上使用该特定对象时，不应该暴露这么多细节，怎么进行参数校验，怎么对字段赋值，这些都是这个对象自己的事情
```



正例：

```js
class MailInfo {
    constructor({subject, text, to, cc, bcc, toMailGroup, ccMailGroup}) {
        if (!subject || !to) {
            throw Error("缺少参数:" + subject ? 'to' : 'subject');
        }
        this.subject = subject;
        this.text = text;
        this.to = to;
        // ...
    }
    
    adjustGroup(group) {
       this.adjustGroup0(group, 'to');
       this.adjustGroup0(group, 'cc');
       return this;
    }
    
    adjustGroup0 (groups = [], field) {
        if (!field) throw Error("缺少参数: field");
        let group = groups.find(group => group.label === this[field]);
        if (group) {
            this[field] = group.children.toString();
        }
    }
}

// call
const mailDto = new MailInfo({
    bcc: this.initPage.bccAddress,
    cc: this.initPage.ccAddress,
    subject: this.initPage.subject,
    text: this.initPage.content,
    to: this.initPage.toAddress,
    ccMailGroup: this.initPage.ccMailMode === '2' ? this.initPage.ccAddress.join(",") : '',
    toMailGroup: this.initPage.toMailMode === '2' ? this.initPage.toAddress.join(",") : ''
}).adjustGroup(this.initPage.mailGroup);
```










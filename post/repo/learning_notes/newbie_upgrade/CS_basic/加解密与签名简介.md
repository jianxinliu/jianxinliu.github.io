[TOC]

# 加密——公钥加密体系简介

## 前言

加密的目的就是为了传输秘密。现实生活中，可以通过降低信息的传播范围来保证信息最小范围的泄露。但计算机不行，就是需要远距离传播，而且是以大声的喊出你要传递的信息的方式。

在这个过程中，就会面临信息泄露的问题，因为在传播的过程中，谁都可以获取信息，谁都可以理解信息，谁都可以修改信息。既然无法像现实生活中用信封和法律来保障所传输信息的安全，只能将信息像写在明信片背面的方式传输，那互联网信息的传输必将考虑新的方式。

从上文了解到，互联网中的信息传输，在到达目的地之前，任何人都可以获取信息、理解信息、修改信息。如果将这三个维度作为信息泄露的程度或者容忍度来看，原始的明文传输的容忍度为 0 ，只要被第三者获取信息就表示信息泄露，且程度达到最大。既然互联网的信息传输不可避免的会被第三方获取，那只能退而求其次，增加第三方对信息的理解难度。
![](http://ww1.sinaimg.cn/large/0076TGp9ly1g1v5g4n3vyj30k30gl794.jpg)

图片来自《改变未来的九大算法》。

## 问题

问题来了，怎样才能做到既增加第三方对信息的理解难度，又不影响接受方对信息的理解呢？这个问题，似乎使用简单的密码也不能解决（凯撒密码），当加密规则被公布，加密形同虚设。（算法的保密被打破，安全性应该以秘钥的保密为基础）

还有一个问题，之前的假设都是基于收信人是已知的，可以通过其他方式商量加密的规则，但互联网世界，收信人是未知的，无法进行**线下商量加密规则**。(基于私密共识进行加密)

## 共享密钥——线上商量加密规则

### 一个有趣的把戏

假设 A 和 B 需要在 C 的注视下完成颜料配方的交换，目的是二人可以调出一样颜色的颜料（共享的密钥）。

```sequence
Title: pub_color\n green
note left of A: private_color \n red
note right of B: private_color \n blue
A->B: green + red
B->A: green + blue
note left of A: 得到 green + blue
note right of B: 得到 green + red
note over A: 混合： green + blue + red
note over B: 混合： green + red + blue
```

此番操作，A 和 B **以不同的顺序**完成了相同颜色的调配，之所以可以达到掩人耳目的作用，是因为颜料混合这个操作是单向操作。在整个传输的过程中，能被公众窃听的有：

- 公开颜色：green
- A -> B 的混合颜色： green + red = yellow
- B -> A 的混合颜色： green + blue = Cyan

颜料混合操作是单向操作，公众如何根据窃听得到的三种颜色还原出 A 和 B 的私有颜色或者混合出最终的颜色呢？答案是不可能的，因为 A 或 B 从没有公开过各自的私人颜色。这就是加密安全依赖秘钥保密而不是算法保密。

#### 使用数字玩颜料的把戏

如果你理解了颜料混合的把戏，你就会理解计算机在互联网上建立共享秘钥的核心机制。但计算机使用数字而不是颜料，需要混合数字。由此出现一个问题，颜料混合是单向操作，数字混合有单向操作吗？为了简单起见，先假设一种单向操作——乘法。由此，参照颜料混合的操作，有如下操作：

A 和 B 共同选取一个公开的数字，假设为 7，A 的私人数字假设是 8，B 的私人数字假设是 3。

```sequence
Title: pub_number\n 7
note left of A: private_number \n 8
note right of B: private_number \n 3
A -> B: 7 * 8 = 56
B -> A: 7 * 3 = 21
note left of A: 得到 21
note right of B: 得到 56
note over A: 混合 7 * 3 * 8
note over B: 混合 7 * 8 * 3
```

#### 现实生活中数字的混合

假设的乘法是单向操作只能是假设的，没有现实意义。那现实中的单向操作是什么呢？反函数可以取消原函数的作用，但如果以现在的计算机算力也很难去计算一个函数的反函数，那使用这个函数进行加密便是暂时安全的。现实生活中，离散指数和离散对数便是这样的一对，目前还没有一种方法能让计算机高效的计算离散对数，离散指数就成了我们寻找的那类单向操作。

离散指数涉及的两个概念：

1. 取余（钟算）
2. 幂函数

可以将钟算和幂函数结合，例如：
$$
3^4 = 3 * 3 * 3 * 3 = 81 = 4(钟的大小为 11)
$$

$$
7^2 = 7 * 7 = 49 = 5(钟的大小为 11)
$$

当需要计算 $$3^5$$ 的钟算结果时，不需要 $$3 * 3 * 3 * 3 * 3$$ ，而可以简单的使用 $$3^4$$ 的钟算结果 （4 * 3）% 11 = 1 即可，这在钟的大小很大，幂函数的底数很大时能简化计算，现实中的钟大小往往是几百位数字的长度，这样，能选取的私人数字的范围也变得很大，也更难被破解。

![](http://ww1.sinaimg.cn/large/0076TGp9ly1g1wbl69rq6j30jf0e7758.jpg)

```sequence
Title: 公开数 \n 钟大小：11 \n 基数：2
note left of A: 私有数字：8
note right of B: 私有数字：9
A->B:(2^8)%11=3
B->A:(2^9)%11=6
note over A: (6^8)%11=4
note over B: (3^9)%11=4
```

双方得到共享密钥 4，之后便可通过类似相加的算法的变体进行通信加密。每次访问 `https` 开头的网站，客户端和服务器之间都会建立一个共享密钥，使用的方法就是迪非-赫尔曼机制或工作原理类似的替代方法。

##### 尝试破解

假设 A 与 B 的通信过程中，钟大小 11 、基数 2 、A 发送给 B 的密文 3 被窃听到，解密的目的是找出 A 的私有数字 8 。试着解密：
$$
2^x \equiv 3 \pmod {11}
$$
偷懒：

![](http://ww1.sinaimg.cn/large/0076TGp9ly1g1wcwe29rsj30mv0kkgnx.jpg)

结果显示，所有整数解为 $$10n + 8,n \in \Zeta$$，这是个离散的解，并且，钟的大小并不大。当钟的大小很小（如 11）时，即使不通过这个公式计算，也可以将结果一一枚举出来，再对比即可得  $$2^8 \equiv 3  \pmod {11}$$ ，但当钟的大小的位数有上百位时，穷举似乎也变得不可能。

##### 钟大小和底数的选取原则

迪非-赫尔曼公开数字最终要的两个属性：钟大小必须为素数；基数必须是钟大小的本原根（primitive root），这也意味着基数的幂终将循环遍钟上的每一个可能的值。

### 结语

以上介绍的是迪非-赫尔曼方法，也被称为密钥交换算法。其他的公钥算法的运作方式不同，可以直接使用接收方宣布的公开消息（public key），直接向潜在的接受方加密一条信息。相反，密钥交换算法接受来自接受方的公开信息，建立一个共享密钥，但信息加密过程通过加法把戏来完成，这需要更少的计算量。

## “其他的公钥算法”——非对称加密

非对称加密（加密和解密使用不同的秘钥）。通信过程如下：

```sequence
Title: 非对称加密通信过程
note over 服务端: 产生公私钥对 S_keypair
note over 客户端: 产生公私钥对 C_keypair
客户端->服务端: 发送公钥 C_pub_key
服务端->客户端: 使用公钥 C_pub_key 加密 smsg
note over 客户端: 使用私钥 C_pri_key 解密 smsg
服务端->客户端: 发送公钥 S_pub_key
客户端->服务端: 使用公钥 S_pub_key 加密 cmsg
note over 服务端: 使用私钥 S_pri_key 解密 cmsg
```

最常见的非对称加密是 RSA 。

> ### 公钥与私钥的产生
>
> 假设Alice想要通过一个不可靠的媒体接收Bob的一条私人消息。她可以用以下的方式来产生一个**公钥**和一个**私钥**：
>
> 1. 随意选择两个大的素数 $$p$$ 和 $$q$$ ，$$p$$ 不等于 $$q$$ ，计算 $$N = p * q$$。
> 2. 根据欧拉函数，求得 $$r = \varphi(N) = \varphi(p)\varphi(q) = (p-1)(q-1)$$
> 3. 选择一个小于 $$r$$ 的整数 $$e$$ ，使 $$e$$ 与 $$r$$ 互质。并求 $$e$$ 关于 $$r$$ 的模逆元，命名为 $$d$$（求 $$d$$ 令 $$ed\equiv1 \pmod r$$ ）。（模逆元存在，当且仅当 $$e$$ 与 $$r$$ 互质）
> 4. 将 $$p$$ 和 $$q$$ 的记录销毁。
>
> $$(N,e)​$$ 是公钥，$$(N,d)​$$ 是私钥。Alice 将她的公钥 $$(N,e)​$$ 传给 Bob，而将她的私钥$$(N,d)​$$ 藏起来。
>
> ### 加密消息
>
> 假设Bob想给Alice送一个消息$$m​$$，他知道Alice产生的$$N​$$和$$ e​$$。他使用起先与Alice约好的格式将$$m​$$转换为一个小于$$N​$$的非负整数$$n​$$，比如他可以将每一个字转换为这个字的[Unicode](https://zh.wikipedia.org/wiki/Unicode)码，然后将这些数字连在一起组成一个数字。假如他的信息非常长的话，他可以将这个信息分为几段，然后将每一段转换为$$n​$$。用下面这个公式他可以将$$n​$$加密为$$c​$$：
>
> $$c\equiv n^e \pmod N $$
>
> 计算$$c​$$并不复杂。Bob算出$$c​$$后就可以将它传递给Alice。
>
> ### 解密消息
>
> Alice得到Bob的消息$$c​$$后就可以利用她的密钥$$d​$$来解码。她可以用以下这个公式来将$$c​$$转换为$$n​$$：
>
> $$n\equiv c^d \pmod N ​$$
>
> 得到$$n$$后，她可以将原来的信息$$m$$重新复原(起先约定好的将 m 转换成 n 的格式)。
>
> ~~解码的原理是~~（太复杂，划掉）
>
> $$c^d \equiv n^{ed}\pmod N​$$
>
> 已知$$ed\equiv 1 \pmod {r}​$$，即 $ ed=1+h\varphi (N)​$。 由欧拉定理得：
>
> ![{\displaystyle n^{ed}=n^{1+h\varphi (N)}=n\left(n^{\varphi (N)}\right)^{h}\equiv n(1)^{h}{\pmod {N}}\equiv n{\pmod {N}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/79569d77cd17c2c265be3b2980878a3a59aa1a7e)
>
> ——参考 [wikipedia](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)

**实践一下：**

### 生成公私钥对

令 $$p = 3,q = 7​$$，则 $$N = 3 * 7 = 21​$$，$$r = (3-1) * (7-1) = 12​$$，令 $$e = 5​$$，因为 $$5*d \equiv 1 \pmod {12}​$$，求得 $$d = 12n + 5,n\in \Zeta​$$，则令 $$d = 5​$$，

公钥（21,5），私钥（21,5）

### 加密

假设要传输的密文为 18，则密文 $$c = 18^5 \pmod {21}$$， 计算得 $$c = 9$$

### 解密

得到密文 $$c = 9$$，则明文为 $$n = 9^5 \pmod {21}$$，计算得 $$n = 18​$$

# 对称加密--DES

DES(Data Encryption Standard),是一种对称加密，加密和解密使用同一个密钥。密钥分发问题（因为 DES 计算量小，一般会用 RSA 将共享密钥进行分发，之后再使用 DES 对传输数据进行加密）。

> DES（数据加密标准）算法主要采用**替换和移位**的方式进行加密，它用56位（64位密钥只有56位有效）对64位二进制数据块进行加密，每次加密对64位的输入数据进行16轮编码，经过一系列替换和移位后，输入的64位原数据转换成完全不同的64位输出数据。

DES 现状——3DES：

> DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。1999年1月，[distributed.net](https://zh.wikipedia.org/w/index.php?title=Distributed.net&action=edit&redlink=1)与[电子前哨基金会](https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E5%89%8D%E5%93%A8%E5%9F%BA%E9%87%91%E4%BC%9A)合作，在22小时15分钟内即公开破解了一个DES密钥。也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用**DES的派生算法[3DES](https://zh.wikipedia.org/wiki/3DES)**来进行加密，虽然3DES也存在理论上的攻击方法。在2001年，DES作为一个标准已经被高级加密标准（AES）所取代。另外，DES已经不再作为[国家标准科技协会](https://zh.wikipedia.org/wiki/NIST)（前国家标准局）的一个标准。

# MD5

> **MD5消息摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的[密码散列函数](https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)，可以产生出一个128位（16[字节](https://baike.baidu.com/item/%E5%AD%97%E8%8A%82)）的散列值（hash value），用于确保信息传输完整一致。

一致性验证:

> MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），**以防止被篡改**。比如，在[Unix](https://baike.baidu.com/item/Unix)下有很多软件在下载的时候都有一个文件名相同，文件扩展名为.md5的文件，在这个文件中通常只有一行文本，大致结构如： [1] 
>
> MD5 (tanajiya.tar.gz) = 38b8c2c1093dd0fec383a9d9ac940515
>
> 这就是tanajiya.tar.gz文件的数字签名。MD5将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的MD5信息摘要。
>
> 利用MD5算法来进行文件校验的方案被大量应用到软件下载站、论坛数据库、系统文件安全等方面。	

数字签名

> MD5的典型应用是对一段Message(字节串)产生fingerprint([指纹](https://baike.baidu.com/item/%E6%8C%87%E7%BA%B9)），以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。

安全认证

> MD5还广泛用于操作系统的登陆认证上，如Unix、各类[BSD系统](https://baike.baidu.com/item/BSD%E7%B3%BB%E7%BB%9F)登录密码、[数字签名](https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D)等诸多方面。如在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，**系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性**。这可以避免用户的密码被具有系统管理员权限的用户知道。
>
> MD5将任意长度的“字节串”映射为一个128bit的大整数，并且是通过该128bit反推原始字符串是困难的，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。
>
> 参考 —— [百度百科](https://baike.baidu.com/item/MD5)

# 何时使用什么加密

RSA 计算时间长，保密性高

DES 计算简单，对密钥的保密性要求高，一般用作关键数据的加密。

MD5 不可逆，常用于加密存储，会丢失原文信息，本质是有损压缩。

# 签名

签名是 RSA 算法的一个应用，签名的过程是，用私钥加密信息，并将这个密文拼接（署名）在消息后面。消息接收者若能用发送者的公钥进行解密，并对比传送的消息一致，则可认为此消息的发送者拥有对应的私钥，且信息没有被篡改。

软件签名：软件厂商会将软件缩减成名为安全哈希（[sha1](https://baike.baidu.com/item/SHA1)）的消息，使用软件厂商的秘钥进行加密，用户下载之后，便可解密消息，再与软件匹配，则可以辨别软件厂商以及是否被篡改（增加病毒）。如何获取公钥？专门的认证机构，随软件分发……



# JWT

[JWT](https://jwt.io/introduction/)（JSON Web Token）也是使用这一套加密和签名的机制来进行身份认证的技术。

# 致谢

全文参考图书《改变未来的九大算法》、wikipedia 相关词条、百度百科相关词条
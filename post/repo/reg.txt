
文档来源： https://zh.javascript.info/regexp-introduction

正则表达式

模式：

一般的： // 内添加模式，在后面接修辞符
动态的： new RegExp(pattern, flags)

字符类：后者称为反向类
	.  => 除换行符外的任意字符
	\d => 数字， \D 非数字
	\s => 空格， \S 非空格
	\w => 一个字符， \W 一个非字符

修辞符

	i 不区分大小写
	g 全局匹配，而不是只匹配第一个
	

量词

{n} 出现的确切次数 如 ： \d{4} 匹配连续 4 个数字
{m,n} 范围

量词缩写
	+  一个或多个， == {1,}
	?  零个或一个， == {0,1}
	*  零个或多个， == {0,}
	
量词匹配默认是贪婪模式，在量词后加 ? 开启懒惰模式

贪婪模式 & 懒惰模式 https://zh.javascript.info/regexp-greedy-and-lazy

'functions "Hello()" and "world()" need match'.match(/".+"/g) => ['"Hello()" and "world()"']  => 结果并不是想要的
使用 ? 开启懒惰模式，即 让 + 尽量少地匹配 /".+?"/g => ['"Hello()"', '"world()"']

	
常用方法

	search(reg) => indexOf 的正则版，返回出现的下标
	match(reg)  => 截取符合条件的部分，返回数组
	replace(reg,rep) => 替换符合的部分
	
	
集合&范围

[] 中的字符或字符类，表示搜索其中的任意一个。或者添加 |
[a-z] 范围,表示搜索 from a to z 中的任意字母
[^a-c] 排除范围，搜索除 a,b,c 之外的字母 ，[^dki]

在 [] 中绝大多数可以不转义，如 +,(),., …… 换句话说，除了在方括号中有特殊含义的字符外，其它所有特殊字符都是允许不添加反斜杠的。



锚点：字符串开始^ 和末尾 $

^ 匹配文本开头
$ 匹配文本结尾

如：
/^Hello/ 测试是否以 Hello 开头
/World!$/ 测试是否以 World! 结尾
/^Hello World!$/ 测试一个字符串是否完全和模式匹配


词边界 \b

用于检测单词边界，如 \bjava\b 可以匹配 'hello java!' 而不能匹配 'hello javascript!'

\b\d\d\b 可以匹配一个两位数

词边界可以是空格，符号(包括下划线)，其他词

如要匹配文本中的 if() 函数，若不加此边界检测，则 sumIf()， sum_if() 也会被匹配。而 \bif\b 则只会匹配 if 函数


捕获组

使用 () 添加组，并在不使用 `g` 修饰的情况下进行捕获组的匹配结果 (如需要 g 修饰，且需要捕获组，则需要使用新 API matchAll)

如： /(\d{4})-(\d{2})-(\d{2})/.match("2020-10-11") 匹配日期，则 match 的结果为 ["2020-10-10","2020","10","11"]

第 0 组为全部结果。此时若需要对时间格式进行改变，就很轻松了，如改为 day/month/year 的格式

命名组 ： /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/ => {0:"2020-10-10",1:"2020",2:"10",3:"11",groups: {year: "2020", month: "10", day: "12"}}

替换捕获组

如上转换日期格式 "2020-10-11".replace(/(\d{4})-(\d{2})-(\d{2})/, '$3/$2/$1') => 11/10/2020
对于命名组： "2020-10-11".replace(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/, '$<day>/$<month>/$<year>') => 11/10/2020
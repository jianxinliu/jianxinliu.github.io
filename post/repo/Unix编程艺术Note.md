# Unix 哲学

简而言之就是 `KISS- Keep It Sample, Stupid!`

具体来说有以下原则

1. 模块原则：使用简洁的**接口拼合**简单的部件（将问题局限在局部，不至于牵一发而动全身，从而降低整体复杂度）
2. 清晰原则：清晰胜于机巧
3. 组合原则：设计时考虑拼接组合
4. 分离原则：策略同机制分离，接口同引擎分离
5. 简洁原则：设计要简洁，复杂度能低则低
6. 吝啬原则：除非别无他法，不要编写庞大的程序
7. 透明原则：设计要可见，以便审查和调试
8. 健壮原则：健壮源于透明与简洁
9. 表示原则：把知识叠入数据，以求逻辑质朴而健壮
10. 通俗原则：接口设计避免标新立异
11. 缄默原则：如果一个程序没什么好说的，就沉默
12. 补救原则：出现异常时，马上退出并给出足够错误信息
13. 经济原则：宁花机器一分，不花程序员一秒
14. 生成原则：避免手工 hack，尽量编写程序去生成程序
15. 优化原则：雕琢前先要有原型，跑之前要先学会走
16. 多样原则：决不相信所谓“不二法门”的断言
17. 扩展原则：设计着眼未来，未来总比预期来的快

## 模块原则

> 使用简洁的接口拼合简单的组件。

> 用**清晰的接口**把若干**简单的模块组合**成一个复杂软件。如此一来，多数问题只会局限于某个局部，那么久还有希望对局部进行改进而不至牵一发而动全身。

清晰的接口意味着各模块的交流符合一定的原则，而设计这样的原则考验程序员的抽象能力，对系统的理解。把复杂的系统进合理的行模块拆分也考验程序员对系统的理解深刻与否。不仅仅是因为模块化使得系统变得清晰，而是做到模块化的过程中，就需要程序员本身对系统进行梳理，将复杂之处以文档、以程序的方式写明，从而也达到让系统变得清晰的目的。

## 清晰原则

> 清晰胜于机巧

> 程序不是给机器看的，而是给人——将来阅读维护源码的人，包括自己——看的。
>
> 
> 清晰的代码不仅仅意味着写注释，也在选择算法和实现时就该考虑到未来的扩展性和可阅读性。为了取得一丁点的性能提升而大幅增加复杂性和晦涩性，这个买卖做不得——这不仅仅是因为复杂的代码容易滋生 bug，也因为它会使日后的阅读和维护工作更加艰难。











  >
  >
  >你必须相信，软件设计时一门技艺，值得你付出所有的只会、创造力和激情。否则，你的视线就不会超越哪些简单、老套的设计和实现；你就会在应该思考的时候急忙跑去编程。你就会在该无情删繁就简的时候反而把问题复杂化——然后你还会反过来奇怪你的代码怎么那么臃肿、难以调试。






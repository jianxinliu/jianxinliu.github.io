# 数据库原理

参考《数据库系统概论》（第五版）王珊、萨师煊编著

## 关系数据理论

不规范的关系模式存在以下问题，考虑这样一个数据表：

| Sno学号 | Sdept系名 | Mname系主任 | Cno课程号 | Grade成绩 |
| :-----: | :-------: | :---------: | :-------: | :-------: |
|   S01   | 计算机系  |    jack     |   CJ01    |    89     |
|   S01   | 计算机系  |    jack     |   CJ03    |    79     |
|   S02   |  中文系   |    rose     |   CZ01    |    90     |
|   S03   |  艺术系   |   Mozart    |   CY01    |    99     |

1. 数据冗余。因为学生 S01 选修两门课，就需要把系名和系主任名存两次。
2. 更新异常。由于存在冗余，系统需要花费巨大代价来维护数据库的完整性。如计算机系更换系主任，则需要更改的数据是计算机系里每一个学生。
3. 插入异常。如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息插入数据库。
4. 删除异常。如果一个系的学生毕业了，需要删除该系学生信息，则这个系及其系主任的信息也被一并删除。

一个关系模式存在以上问题，是因为这个模式中存在不恰当的依赖，可以通过拆分进行规范化。

S(Sno,Sdept，Sno->Sdept)。Sno 确定 Sdept

SC(Sno,Cno,Grade，(Sno,Cno)->Grade)。一个学生选修一门课程就有一个分数

DEPT(Sdept,Mname，Sdept->Mname)。一个系有一个系主任。

如此拆分之后，去掉了传递函数依赖。原先存在 Sno -> Sdept -> Mname 的传递函数依赖。

### 规范化

首先需要知道的一些概念。

**函数依赖**：普遍的存在于生活中，和数学中的单值函数类似，每个 x 的值都确定一个 y 值，函数依赖指的是当记录的一个属性 A 确定时，另一个与属性 A 存在函数依赖的属性 B 也随之确定。此处 **A 可确定 B ，则称为 B 函数依赖于 A**。

**完全函数依赖**：通俗的说，完全函数依赖指的是。X 的任一真子集都不能确定 Y ，只有 X 本身可以确定 Y ，即 X 中没有多余属性。

**平凡函数依赖**和**非平凡函数依赖**：X → Y ，但 Y ∈ X，则称 X → Y 是**平凡的函数依赖**(X 确定 Y ，但 Y 是 X 的一个子集)。对于任一关系模式，平凡的函数依赖都是必然成立的，它不反映新的语义，故总是讨论非平凡的函数依赖。对于 X → Y，但Y !∈ X，则称 X → Y 是非平凡的函数依赖（X 确定 Y ，但 Y 不完全是 X 的子集）。

**候选码 candidate key**：若关系中的某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为**候选码**。（能唯一确定一个元组的最小属性集合即为候选码）。如：在学校里，学号、身份证号都能唯一确定一个学生，则学号、身份证号是候选码。

**主码 primary key**：若一个关系有多个候选码，则选其中一个作为主码。例如：学号和身份证号任选一个属性作为主码（主键）。

**主属性**和**非主属性**：候选码的诸属性称为主属性，不包含在候选码中的属性被称为非主属性。例如：学号和身份证都是主属性，年龄和性别都是非主属性（或称非码属性）。

在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式中的所有属性都是这个关系模式的候选码，称为**全码**。

规范会就是要消除不合适的函数依赖。

### 第一范式1NF

是最基本的规范化要求。指的是**分量不可再分**。

### 第二范式2NF

在满足第一范式的基础上，每个非主属性完全函数依赖于任何一个候选码。

### 第三范式3NF

不存在非主属性对码的传递函数依赖。



范式向下兼容，如满足3NF，则必定满足 2NF 和 1NF。其中1NF称为低一级的范式。一个低一级范式的关系模式可以通过模式分解转换为若干个高一级范式的关系模式集合，这个过程叫规范化。

## 数据库恢复技术


### 事务的基本概念

事务处理技术主要包括数据库恢复技术和并发控制技术。

事务是指一组满足 ACID 特性的操作，通过 `commit` 提交一个事务，通过 `rollback` 回滚一个事务。

#### ACID

1. **原子性** （Atomicity）。事务是原子性的，一个事务中包含的操作要么全部成功，要么全部失败。回滚的实现：利用回滚日志记录正向操作，回滚时进行反向操作即可回滚。
2. **一致性**（Consistency）。一致性是与原子性密切相关的。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。比如转账操作就是一个事务，从 A 账户转账给 B 账户 100 元，需要执行 `A - 100` 和 `B + 100` 两个操作，这两个操作要么都执行成功，要么都执行不成功，数据库都是属于一致性状态。若只其中一个操作执行成功，数据库不属于一致性状态。
3. **隔离性**（Isolation）。一个事务的执行不会受到其他事务的干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
4. **持续性**（Durability）。也称永久性（Permanence）。指一个事务一旦提交，其对数据库所做的改变就应该是永久的，后续的操作或故障不应该对其执行结果有任何影响。

### 故障的种类

主要分为四类，需要注意的有前两类及其应对方法。

1. **事务内部的故障**。事务内部的故障大多是非预期的，是不能由应用程序处理的。意味着事务没有达到预期的终点（commit 或者 rollback）因此，数据库可能处于不正确状态，恢复程序需要再不影响其他事务运行的情况下，强行回滚该事务，撤销该事务对数据库做出的任何修改，这类操作成为**事务撤销（UNDO）**。
2. **系统故障**。是指造成系统停止运行的事件，使得系统要重新启动。系统停止时，存在两种情况：1. 事务尚未完成，非正常终止，部分数据已写入物理数据库，部分未写入。2. 已经完成的事务尚有部分或全部数据停留在缓冲区，还未写入物理磁盘。系统故障造成的这两种情况，有两种解决办法。对于第一种情况，需要撤销所有未完成事务。对于第二种情况，需要对已提交的失去结果重新写入数据库，即**重做（REDO）**。
3. 介质故障。系统故障成为**软故障**，介质故障成为**硬故障**。是为硬件损坏导致的事务失败、数据丢失。
4. 计算机病毒。

#### UNDO VS REDO

- undo 应用于撤销未正确完成的事务对数据库所做的修改。
- redo 应用于重做已经完成但数据未进行持久化的事务。

**恢复的原理十分简单：冗余。**数据库中任何一部分被破坏或不正确的数据都可以根据存储在系统别处的冗余数据来重建。DBMS中的各种用于恢复的日志。虽然恢复的原理很简单，但具体的技术实现却相当复杂。

### 恢复技术的实现

恢复机制设计这么两个关键问题：如何建立冗余数据，以及如何利用冗余数据实现数据库恢复。**建立冗余数据最常用的技术是数据转储和登记日志文件（logging）**：

1. **数据转储**。人为的定期对数据进行转移，亦成为数据备份、副本(Backup)。当数据库遭到破坏时，可以从副本进行恢复，但只能恢复到最近一次转储时的数据，要想恢复到故障发生时的状态，还需要重新运行自转储以后的所有更新事务（采用日志文件记录）。例如，转储频率是十分钟，若在一次转储后的六分钟时系统发生故障，则采用副本载入恢复不能恢复这最后六分钟的数据，这需要重新运行这六分钟的所有更新事务。**注意：**转储是十分耗费时间和资源的，不能频繁进行，需要结合数据库使用情况，制定合理的转储周期。
2. **登记日志文件**。日志文件时用来记录事务对数据库的更新操作的文件，主要有两种格式：以记录为单位和以数据块为单位。**注意：** **必须先写日志后写数据库**。写日志和写数据库是两个操作，有可能在这之间发生故障，导致只完成了其中一个操作。如果先写数据库，则日志中没有该操作的记录，后期也就无法恢复这个操作。如果先写日志，但没有数据库修改，按日志问价恢复时只不过多一次不必要的 UNDO ，并不会影响数据库的正确性。例如：一次 `UPDATE USER SET name='A' WHERE name='B'`操作只写入了日志但未写入数据库，则在恢复时执行一次 `UPDATE USER SET name='B' WHERE name='A'`,但由于数据库里的数据仍然为 `name=B` 则再次 set 时不会影响数据库的正确性。

## 并发控制技术

事务是并发控制的基本单位。数据库的并发会破坏事务的 ACID 特性，为了保护事务的**隔离性**和**一致性**，DBMS 需要对并发操作进行正确的调度。

并发操作带来的数据不一致包括：丢失修改、不可重复读和脏读。

1. **丢失修改。lost update** ：两个事务读入同一数据并修改，后一提交的事务覆盖了前者的修改，导致前者的修改丢失。
2. **不可重复读。non-repeatable read** ：在并发环境下，一个事务对同一数据的多次读取结果不相同，造成的原因有三，其中后二者也被称为幻影（phantom row）现象：
   1. 读取的间隔，数据被其他事务修改（数据不一致）
   2. 读取的间隔，其他事务删除数据，某些记录消失（少数据）
   3. 读取的间隔，其他事务增加数据，多出一些记录（多数据）
3. **脏读。dirty read**：事务并发情况下，一事务对数据做出修改之后，被另一事务读取到新数据，但是由于某种原因，前者的修改被撤销，此时，后者取到的数据就是前者的脏数据，是不正确的数据。

并发控制的主要技术有：**封锁**（locking）、**时间戳**（timestamp）、**乐观控制法**（optimistic scheduler）、**多版本并发控制**（multi-version concurrency control,MVCC）。

### 封锁

封锁是实现并发控制的重要技术，DBMS 中的封锁和编程语言中的加锁是一样的，都是为了不被其他事务（线程、进程）干扰。同样的，封锁类型分为：排他锁（exclusive locks ,X 锁、写锁）和共享锁（share locks, S 锁、读锁）。注：同性锁可重入，异性锁互斥。

#### 三级封锁协议

封锁协议就是对加锁规则的定义，包括：何时申请什么锁，持锁时间，何时释放等问题。三级封锁协议分别在不同程度上解决以上并发操作带来的数据不一致问题。

1. 一级封锁协议（写加锁）。事务在**修改数据**前必须先加 X 锁，**直到事务结束**时释放。事务结束包括`commit`，`rollback`。<u>一级封锁协议可防止丢失修改，并保证事务是可恢复的</u>。因为读不加锁，故不能保证可重复读和不脏读。**如何防止丢失修改**：丢失修改是因为并发操作破坏了隔离性，导致多个事务修改同一数据，前者所做修改被覆盖。一级封锁进行写加锁，保护了事务的隔离性。
2. 二级封锁协议（单次读加锁）。在一级的基础上，每次读加读锁，**读完即释放**。<u>二级封锁在一级的基础上，还可以防止脏读</u>。由于读完立即释放锁，故不可保证可重复读。**如何防止脏读**：脏读的问题在于一个事务的修改未完成时就进行读取。二级封锁进行读加锁，故在一个事务未完成时，加不上读锁，故不会产生脏读。
3. 三级封锁协议（读加锁）。在一级的基础上，读前加读锁，**直到事务结束**释放锁。<u>在前两级的基础上，还可进一步防止不可重复读</u>。**如何防止不可重复读**：因为加读锁，直到事务结束才释放锁，故在事务中的多次读取间隙，不会出现数据被修改的情况，就不会出现不可重复的。

三级封锁协议之间的区别在于申请什么锁，以及什么时候释放锁。封锁协议级别越高，一致性程度越高

#### 活锁与死锁

把事务类比为进程，则也存在活锁和死锁。

避免活锁的方式是先来先服务。

死锁问题和操作系统中的死锁问题一样，主要是死锁预防和死锁解除。

死锁预防的思路是破坏死锁产生的条件。操作系统中广为采用的死锁预防在数据库上并不适用，故数据库中解决死锁的普遍做法是**诊断并解除死锁**。（注：数据库中预防死锁的办法有：一次封锁法(同操作系统中一次性给进程分配所需的所有资源)，顺序封锁法）

死锁的诊断与解除。

死锁的诊断主要是：1. 超时法，事务等待时间超过一定时限就认为发生了死锁。太死板。2. **事务等待图法**。事务等待图是一个有向图，节点表示事务，边表示等待关系（A->B表示A等待B），**若图中存在回路，则说明死锁存在**。

死锁的解除：选择一个处理死锁代价小的事务进行撤销，释放此事务持有的所有锁。当然，撤销之后还需要恢复。

#### 封锁的粒度

封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元也可以是物理单元。以关系数据库为例，封锁对象可以是：属性值、属性值的集合、元祖、关系、索引项、整个索引甚至整个数据库，也可以是页（数据页或索引页）、物理记录等物理单元。

封锁粒度与系统的并发度和并发控制的开销密切相关。**多粒度封锁**支持对不同的事务采取不同的封锁粒度，从而满足不同需求。

**多粒度树**。根节点是整个数据库，表示最大粒度，叶节点表示最小的粒度。多粒度树封锁协议允许书中每个节点被独立加锁，对一个节点加锁意味着**此节点的后裔都被隐式加上同类型的锁**。因此一个数据对象可能以两种方式封锁，显示和隐式。

由于存在隐式加锁，故在检查时比较麻烦（上下级检查是否有锁冲突）。因此引入**意向锁**。如果对一个节点加意向锁，则说明该**节点的下层节点**正在被加锁，对任一节点加锁前，必须先对其上层节点加意向锁。例如，对任一元组加锁时，必须先对其所在的数据库和关系加意向锁。

意向锁的种类：

1. 意向共享锁（Intent Share Lock,IS锁）。给节点加 IS 锁，表示其后裔节点拟（意向）加 S 锁。
2. 意向排他锁（Intent Exclusive Lock,IX锁）。给节点加 IX 锁，表示其后裔节点拟（意向）加 X 锁。
3. 共享意向排他锁（Share Intent Exclusive Lock,SIX锁）。给节点加 SIX 锁，表示对其加 S 锁，再加 IX 锁（SIX = S + IX）。

各锁的相容矩阵，Y 表示相容，N 表示不相容。

| T1\T2 |  S   |  X   |  IS  |  IX  | SIX  |  -   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|   S   |  Y   |  N   |  Y   |  N   |  N   |  Y   |
|   X   |  N   |  N   |  N   |  N   |  N   |  Y   |
|  IS   |  Y   |  N   |  Y   |  Y   |  Y   |  Y   |
|  IX   |  N   |  N   |  Y   |  Y   |  N   |  Y   |
|  SIX  |  N   |  N   |  Y   |  N   |  N   |  Y   |
|   -   |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |

例如：事务 T1 要对关系 R 加 S 锁，则要首先对数据库加 IS 锁，检查数据库和 R 是否已经加了不相容的锁（X 或 IX），不再需要搜索和检查R 中的元组是否加了不相容的锁。
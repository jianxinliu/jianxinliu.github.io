# 数据库优化思路

ref:https://juejin.im/post/5a9ca0d6518825555c1d1acd

## SQL优化

### 从右到左的执行顺序

可以根据SQL解析器**从右到左的顺序**的执行顺序来优化SQL

#### 表名顺序

数据库的解析器按照**从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理** 

在FROM子句中包含多个表的情况下：

- **如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推**
- **也就是说：选择记录条数最少的表放在最后**（类似操作系统中的短作业优先调度算法）

如果有3个以上的表连接查询：

- **如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推**。
- **也就是说：被其他表所引用的表放在最后**（这样操作可以减少因需要加载依赖而产生的上下文切换）

#### WHERE子句的顺序

数据库采用自**右而左的顺序解析WHERE子句**,根据这个原理,**表之间的连接必须写在其他WHERE条件之左**,那些**可以过滤掉最大数量记录的条件必须写在WHERE子句的之右**。 

也就是说先把最大数量的记录进行缩减再进行表连接。

### Select子句中避免使用 * 号

\* 号虽然可以选择所有列，但**需要查询数据字典才能得到表的全部列信息**，是要花费更多的时间。所以为了效率和时间，宁可在写SQL语句时指明确切的列。

### 用`truncate` 代替 `delete`

当需要删除表内所有数据而不删除表结构时，可以使用`truncate`代替`delete`。

`truncate`、`delete`和`drop`的区别:

- truncate:属于DDL，不可回滚，不可带WHERE条件，删除表内容，速度快
- delete：属于DML，可回滚，可带WHERE条件，只删除表内容，删除速度慢（需要逐行比较）
- drop：属于DDL，不可回滚，不可带WHERE条件，删除表结构和表内容，删除速度快

### 多使用内部函数

如 MySQL 的`concat()`函数会比直接进行字符拼接速度快，因为内部函数是经过优化的。

### 使用表或列的别名

当表名或列名达到一定长度时应该使用别名来**减少扫描的长度**。

### 善用索引

索引是用于提高检索速度的，当表的记录量非常大时刻考虑使用索引。

但是，当**表频繁进行CUD操作时，使用索引的优势便不明显，因为需要频繁更新索引**

### SQL大写

SQL语句本身就是大写的，只是DBMS兼容小写，Oracle会将小写转换成大写再执行，这样增加处理时间了。

### 用 `>=` 代替 `>`

```sql
  低效：
  SELECT * FROM EMP WHERE DEPTNO > 3   
  首先定位到DEPTNO=3的记录并且扫描到第一个DEPT大于3的记录
  高效：
  SELECT * FROM EMP WHERE DEPTNO >= 4  
  直接跳到第一个DEPT等于4的记录
```

### 用`in` 代替 `or`

```sql
  select * from emp where sal = 1500 or sal = 3000 or sal = 800;
  select * from emp where sal in (1500,3000,800);
```

## 数据库结构优化

- 范式优化： 比如消除冗余（节省空间。。）
- **反范式优化：比如适当加冗余等（减少join）**
- 拆分表： 垂直拆分和水平拆分